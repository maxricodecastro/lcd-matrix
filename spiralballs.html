<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Exploding Ball Clusters</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }
    #world {
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <!-- Physics engine -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, Bodies, Body, Composite, Vector } = Matter;

    const engine = Engine.create();
    const world = engine.world;
    engine.gravity.y = 0.5; // Reduced gravity for more floaty feel

    const canvas = document.getElementById('world');
    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resize();
    window.addEventListener('resize', resize);

    const render = Render.create({
      canvas,
      engine,
      options: {
        width: canvas.width,
        height: canvas.height,
        wireframes: false,
        background: '#ffffff'
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // Colors for the balls
    const COLORS = ['#ff66b2', '#66ff99', '#66ccff', '#ffd966', '#ff8c66', '#c266ff'];

    // Track active ball clusters
    const ballClusters = new Map(); // Map of cluster ID to array of balls

    function createBallCluster(x, y) {
      const numBalls = 7 + Math.floor(Math.random() * 6); // 7-12 balls
      const balls = [];
      const clusterId = Date.now(); // Unique ID for this cluster

      for (let i = 0; i < numBalls; i++) {
        const radius = 15 + Math.random() * 15; // 15-30px radius
        const angle = (Math.PI * 2 * i) / numBalls;
        const distance = 30 + Math.random() * 20; // Initial spread distance
        
        const ballX = x + Math.cos(angle) * distance;
        const ballY = y + Math.sin(angle) * distance;
        
        const ball = Bodies.circle(ballX, ballY, radius, {
          restitution: 0.8,
          friction: 0.002,
          density: 0.001,
          render: { fillStyle: COLORS[Math.floor(Math.random() * COLORS.length)] }
        });

        // Add initial velocity in a slight outward direction
        const velocity = {
          x: Math.cos(angle) * 2,
          y: Math.sin(angle) * 2
        };
        Body.setVelocity(ball, velocity);

        balls.push(ball);
        Composite.add(world, ball);
      }

      ballClusters.set(clusterId, balls);

      // Trigger explosion after a delay
      setTimeout(() => triggerExplosion(clusterId), 1000);
    }

    function triggerExplosion(clusterId) {
      const balls = ballClusters.get(clusterId);
      if (!balls) return;

      // Calculate center of mass
      const center = balls.reduce((acc, ball) => ({
        x: acc.x + ball.position.x,
        y: acc.y + ball.position.y
      }), { x: 0, y: 0 });
      center.x /= balls.length;
      center.y /= balls.length;

      // Apply explosion force
      balls.forEach(ball => {
        const dx = ball.position.x - center.x;
        const dy = ball.position.y - center.y;
        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
        const forceMagnitude = 0.015;

        Body.applyForce(ball, ball.position, {
          x: (dx / distance) * forceMagnitude,
          y: (dy / distance) * forceMagnitude - 0.01 // Slight upward bias
        });
      });

      // Remove balls when they're off screen
      const checkInterval = setInterval(() => {
        const allOffScreen = balls.every(ball => 
          ball.position.y > canvas.height + 100 || // Below screen
          ball.position.x < -100 || // Left of screen
          ball.position.x > canvas.width + 100 // Right of screen
        );

        if (allOffScreen) {
          clearInterval(checkInterval);
          balls.forEach(ball => Composite.remove(world, ball));
          ballClusters.delete(clusterId);
        }
      }, 100);

      // Safety cleanup after 5 seconds
      setTimeout(() => {
        clearInterval(checkInterval);
        if (ballClusters.has(clusterId)) {
          balls.forEach(ball => Composite.remove(world, ball));
          ballClusters.delete(clusterId);
        }
      }, 5000);
    }

    // Handle click/touch events
    function handleInteraction(event) {
      const x = (event.touches ? event.touches[0].clientX : event.clientX);
      const y = (event.touches ? event.touches[0].clientY : event.clientY);
      createBallCluster(x, y);
    }

    window.addEventListener('mousedown', handleInteraction);
    window.addEventListener('touchstart', handleInteraction);
  </script>
</body>
</html>
